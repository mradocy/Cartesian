

TECHNICAL ASPECT:
Cartesian is written in Javascript/HTML5, which is not the fastest platform in the world.  There is no real reason for this, other than I wanted to add familiarity with some of the most popular web languages to my repertoire.  Being able to be played in a browser is a bonus, but this was not a huge priority.  When the project started as just ideas in a text document it was clear that it did not have to be written in a super optimized fashion to be a solid game, so why not?  I had experience with AS3, C++, Haxe, and now Javascript, with Unity/C# or Unreal likely coming next.

Anyway, making the "laser" system for Cartesian is clearly imperative.  Calculating and rendering several potentially complicated chain of laser reflections every frame is no trivial task either.  In fact covering the entire room with lasers is the only way to damage a certain boss late in the game...
<griddy>
My intuition tells me that finding collisions between lasers and the tiles in a grid would be faster by hand than letting Phaser's physics engine (which isn't great, as it turned out) find them.  Whatever raycasting object pruning on every single tile square object whatever optimization method it uses is likely not as good as just looking up the tile properties corresponding to the coordinates the line passes through.  It involves a loop and some "y = mx+b" level algebra.  Pretty simple.

How the tile info was stored is a bit more interesting.  It is not as simple as having a grid of 1s and 0s with 1 indicating a tile's presence.  That says nothing about the color of the side of the tile the laser hit, which determines if a laser gets reflected or not.

So instead let's use a grid of custom objects representing tiles.  Each tile has 5 properties: 4 for the color of each side, and 1 for the material of the tile (normal, transparent, breakable, etc.).  Well, personally custom objects in Javascript rub me the wrong way, with how accessing properties works like a string-keyed map.  It can potentially slow the game down, and who knows the toll garbage collection would take on it (recycling objects helps though).  But these are simple properties, all of which can be represented with an enumeration/integer.  So let's use an array of numbers for each tile.  But we can do better than that...

How about representing each tile with a string?  Strings in C are arrays of chars (integers), and this would be nearly the same thing.  The first index of the string represents the color of the top of the tile, second represents the right side, and so on.  An empty string represents no tile.  Tiles never change (with the exception of breakable tiles; they get turned into "no" tile), so strings being immutable in Javascript is not an issue.  An 2D array of these strings is the best way I can think of to quickly obtain information about a grid of tiles.

At the time this was written this is the most interesting optimization the game has.  Lasers are drawn with primitives instead of images, certain assets are cached and recycled for multiple uses, but these are pretty basic.  There is still more optimization to be done, especially with the load time for booting the game in a browser.  I will get to those eventually.


LEVEL DESIGN:
There are a few fundamental rules that games should follow.  The mechanics should be easy to understand, yet deep enough for the player to continuously have an engaging experience.  They also have to look good.  In a puzzle game like Cartesian, there is another important design concept, which can be summed up as: "for every puzzle, there is one solution".  Obviously every level needs to be beatable, but it's also important that no second "easier" way exists to beat it.  Levels are constructed with a purpose.  They are meant to be stimulating;  they strive to test the player's abilities or teach them something new.  If a player "short-circuits" a level by finding an unintended shortcut, the purpose of the level is lost.  This problem can come up when designing any puzzle game, and Cartesian is no exception.

Here is a simple example I quickly discovered when I started to construct Cartesian's levels.  The path of a laser has a start (the player) and an end (some non-reflective surface).  But it may be possible for the same path to be made if the player instead started where the laser ended, and firing in the opposite direction.  The images below show a puzzle that illustrate this:
<intended>
Here is an alternate solution that uses the same "path":
<alternate> (In retrospect, this image is not a great example because this solution isn't easier to figure out than the main one)
So we need to make the alternate path infeasible somehow.  One approach is easy: just put another laser there that the player cannot cross.  Problem solved!
<inelegant>
We see a seemingly random laser pointing at the ground in a corner.  Subjectively, it looks awkward and unnatural.  To me it just feels like lazy design.  Admittedly in some of Cartesian's levels I am forced to restrict the player with a laser like this when there was no other way.  But in this case, there is:
<better>
We simply added a wall that would cause the laser to stop in the air.  Recall the player has to hold in place for a second firing the laser for the orbs to activate.  So even if the player could jump that high, the laser could not be fired in reverse to solve the puzzle in an alternate way.  The elegance lies with how the closer wall looks totally unremarkable; it simply blends in with the rest of the level.  This trick is used very often in Cartesian, and it is hard to notice without being told about it.

This is one way I try to make levels that are simultaneously structurally sound and also nice to look at.  Admittedly "Elegance" is very subjective, and feels like a term used mostly by passionate borderline-crazy mathematics professors when talking about a formula.  I suppose it rubbed off on me, because I cannot think of a better way to describe why I prefer one design to another.  Level design is absolutely paramount in a puzzle game, perhaps more so than in any other genre of gaming.  So if there was anything worth being passionate and crazy over, this is it.




BOSSES:
Despite being a puzzle game, Cartesian features boss fights with some light combat elements, 4 in all.  In a game mostly consisting of rooms devoid of life, a test of wits against a moving, breathing, animate enemy would provide a refreshing change of pace.  But to not diverge from the puzzle nature of the game too much, combat should be more about figuring out what to do, rather than having mastery of precise movements like in an action game.  Notice that none of the bosses are actually fast enough to kill the player until they're almost dead themselves.  Making bosses that fit just right in Cartesian was tricky, and probably why they're uncommon in most other puzzle games.  These boss fight levels took such a disproportionate amount of time to make compared to all the other levels in the game.  They require their own animations, mechanics, AI programming, sound effects, and so on.  Sometimes I wonder if all the effort could have been better used making more levels or other gameplay mechanics, but ultimately I think they were worthwhile additions that gave the game character and let it stand out.

One of the more intricate bosses is one encountered in the middle of the game, named 'Midel' for that reason.  Every part of her body reflects red lasers, save for the dark colored chest area in the front; at this point in the game it would be very easy for the player to deduce that this is the weak point.  But part way through the battle, Midel snaps off her crystalline hair structures and uses them to shield laser shots.  The key is to angle the laser diagonally from above so that it reflects off her own hair swords and hit the weak spot.  The player is tasked in figuring this out all while also avoiding attacks from Midel herself.

Cooperation between the technical and artistic standpoints of the design was absolutely crucial.  A simple example is Midel's laser hitbox: the dimensions for the reflective edges needed to perfectly match up with the sprite.  But I want to draw attention to her swords, whose balance between form and function took a lot of effort to really nail down.  The swords needed to be shaped and angled in such a way so that a laser travelling diagonally down, and only diagonally down, could consistently reflect off them and hit the weak point.  But they also had to look intimidating, interesting, and not awkward as hell.  It took some guessing and fiddling, especially since nobody holds swords vertically like this.  I also had the swords sway a little in the idle animation to make the boss feel more alive, and again, reduce awkwardness.  But not sway too much, or else it would be too hard for the laser to reflect correctly.  Finally, remember the swords were originally snapped off from Midel's hair.  She'd still have to look good when the swords are attached.  This is why the swords had to be curved a little, as having just straight crystalline hair would've looked weird.  Many adjustments had to be made over time to accompany all these restrictions.  Whether or not my best attempt works well is up for you to decide.

The point I want to make is that this requires such a tight mixture of insight from both a gameplay standpoint and artistic standpoint.  If a team consisting of someone that just did programming and someone that just did art worked on Midel, I honestly don't think it could be done.  In past projects I've noticed it's very hard to get an artist to not go beyond restrictions very important from the gameplay perspective.  If the angle of the sword was a little off, for example, either the reflected laser would veer off the intended course or the laser hitbox wouldn't match up with the sprite.  It just goes to show that in game development, you really have to be familiar with all aspects that go into game design, and not just be a one trick pony.